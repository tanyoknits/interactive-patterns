{"version":3,"file":"static/js/853.0107d464.chunk.js","mappings":"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","sources":["projects/pine-pullover/SleeveInstruction.tsx","../../truly-even/src/utils.ts"],"sourcesContent":["import { SectionInstruction, getInchAndCm } from \"@tanyoknits/shared\";\nimport { InstructionProps } from \"./Instruction\";\nimport { getTruelyEven } from \"@tanyoknits/truly-even\";\n\ninterface SleeveInstructionProps extends InstructionProps {\n  centerChart: { sts: number; row: number };\n}\n\nexport default function SleeveInstruction({\n  schema,\n  measurement,\n  centerChart,\n}: SleeveInstructionProps) {\n  const startSts = schema.total.sleeve;\n  const { decRows, finalDec } = schema.sleeve;\n\n  const chartStartRow = finalDec.row - centerChart.row;\n\n  let stsCountAtChartStart = startSts;\n  for (let i = 0; i < decRows.length; i++) {\n    if (decRows[i] + 1 <= chartStartRow) {\n      stsCountAtChartStart -= 2;\n    }\n  }\n\n  const chartStartPoint = Math.floor(\n    (stsCountAtChartStart - centerChart.sts) / 2\n  );\n\n  // final decrease on\n  const decText = getTruelyEven(\n    stsCountAtChartStart,\n    stsCountAtChartStart - finalDec.sts,\n    {\n      avoidEnds: true,\n      sts: \"k2tog-ssk\",\n      count: 2,\n      hasDoubleNest: true,\n    }\n  );\n\n  return (\n    <>\n      <SectionInstruction\n        intro=\"ðŸª¡ Move the sts in scrap yarn or stitch holder to US 11 / 7mm needle.\"\n        rowType=\"Pick up\"\n        rows={[\n          {\n            text: `underarm ${schema.underarm} sts`,\n            notes: `sleeve total ${startSts} sts`,\n          },\n        ]}\n        afterList={[\n          `Pm after ${Math.round(\n            schema.underarm / 2\n          )} sts - this is BOR of sleeve. Rnd 1 start here.`,\n        ]}\n        notes={`Following row numbers are based on the sleeve length from underarm, ${getInchAndCm(\n          measurement.sleeve_length_from_underarm\n        )}.`}\n      />\n      <SectionInstruction\n        rowType=\"Next rnd\"\n        rows={[{ text: `k${startSts}` }]}\n        notes={`Rep the prev row to approx ${getInchAndCm(2)}.`}\n      />\n      <SectionInstruction\n        title=\"Taper sleeve\"\n        intro=\"Dec 1 at each side of marker across two rnds\"\n        rowType=\"Rnd\"\n        startRowID={decRows[0] - 1}\n        rows={[\n          { text: \"k till 2 sts bef marker, k2tog\" },\n          {\n            text: `k2, ssk, k till marker`,\n            notes: `2 sts dec, ${startSts - 2} sts remain`,\n          },\n        ]}\n        notes={`rep at row ${decRows\n          .slice(1)\n          .map((row) => `${row}/${row + 1}`)\n          .join(\", \")} (${startSts - decRows.length * 2} sts remain)`}\n      />\n      <SectionInstruction\n        title=\"Chart A before cuff\"\n        intro={`While you work taper sleeve dec, start chart A at row ${chartStartRow}.`}\n        beforeList={[\n          `After dec, ${stsCountAtChartStart} sts left.`,\n          `From BOR, pm A at ${chartStartPoint} sts (mA is the beg of chart A.)`,\n          `From A, pm B at ${centerChart.sts} sts (mB is the end of chart A.)`,\n        ]}\n        rowType=\"Rnd\"\n        startRowID={chartStartRow - 1}\n        rows={[{ text: `k till mA, smA, work chart B, smB, k till BOR` }]}\n      />\n      <SectionInstruction\n        title=\"Final decrease\"\n        rowType=\"Rnd\"\n        startRowID={finalDec.row - 1}\n        rows={[\n          {\n            text: decText.sts.join(\", \"),\n            notes: `${finalDec.sts} dec'd, ${\n              stsCountAtChartStart - finalDec.sts\n            } sts left`,\n          },\n          { text: `Change to smaller needle, k all` },\n        ]}\n      />\n      <SectionInstruction\n        title=\"Hem 1x1 ribbing\"\n        rowType=\"Rnd\"\n        startRowID={finalDec.row + 1}\n        rows={[{ text: `(k1, p1) repeat (-) till BOR` }]}\n        notes={`Rep the prev row to approx ${getInchAndCm(\n          measurement.cuff_length\n        )}.`}\n      />\n    </>\n  );\n}\n","import {\n  getDec2StsList,\n  getChangeStsList,\n  getStsListRepets,\n} from \"@tanyoknits/shared\";\n\nexport type IncStsType = \"m1-m1\" | \"m1r-m1l\" | \"m1l-m1r\";\nexport type DecStsType =\n  | \"k2tog-k2tog\"\n  | \"ssk-ssk\"\n  | \"k2tog-ssk\"\n  | \"ssk-k2tog\"\n  | \"cdd-cdd-k2tog\"\n  | \"k3tog-k3tog-k2tog\"\n  | \"sk2p-sk2p-ssk\"\n  | \"k3tog-sk2p-ssk\"\n  | \"sk2p-k3tog-k2tog\";\n\nexport interface OptionType {\n  avoidEnds: boolean;\n  sts: DecStsType | IncStsType;\n  count: number;\n  hasDoubleNest: boolean;\n}\n\n// Get truly even increase or decrease instruction\nexport function getTruelyEven(\n  startSts: number,\n  endSts: number,\n  option: OptionType\n): { sts: string[]; avoidEndAvailable: boolean; doubleNestAvailable: boolean } {\n  let avoidEndAvailable = true;\n  let doubleNestAvailable = false;\n\n  // Inc/Dec stitch point list\n  const stsPoints =\n    option.count === 3\n      ? getDec2StsList(startSts, endSts)\n      : getChangeStsList(startSts, endSts);\n  const { avoidEnds, sts, count, hasDoubleNest } = option;\n\n  // If users don't want to end with inc/dec at the end, start it early\n  const tailSts = Math.floor((stsPoints[0] - count) / 2);\n  if (tailSts === 0) {\n    avoidEndAvailable = false;\n  }\n  if (avoidEnds) {\n    stsPoints[0] -= tailSts;\n  }\n\n  // Generate text from all 'k' include increase or decreases stitches\n  const incDecStsList = stsPoints.map((stsCount, i) => {\n    const stsTypes = sts.split(\"-\");\n    return count === 3 &&\n      i === stsPoints.length - 1 &&\n      (endSts - startSts) % 2 !== 0 // orphan increase for 2 sts dec\n      ? `k${stsCount - 2}, ${stsTypes[2]}`\n      : `k${stsCount - count}, ${\n          // For increase, count is 0 since it's adding a new M stitch\n          i < stsPoints.length / 2 ? stsTypes[0] : stsTypes[1]\n        }`;\n  });\n  if (avoidEnds && tailSts > 0) {\n    incDecStsList.push(`k${tailSts}`);\n  }\n\n  // Repeated stitches are now presented with \"X times\"\n  const stsMultiplied: string[] = getStsListRepets(incDecStsList);\n\n  // Check multiple increase groups are repeated\n  // e.g., [(k2, m1), (k3, m1) x 3] x 4\n  let repeatCheckIdx = 0;\n\n  const nested = stsMultiplied.reduce((labels: string[], sts, idx) => {\n    // Skip sts that's already applied to the previous repeats\n    if (idx < repeatCheckIdx) {\n      return labels;\n    }\n    // Recursive: if repeats aren't found, increase the number of repeated sts\n    // start with two (e.g., (k2, m1), (k3, m1) x 3)\n    function checkRepeats(count: number): string[][] {\n      const repeats = [stsMultiplied.slice(idx, idx + count)];\n      for (let i = idx + count; i <= stsMultiplied.length - count; i += count) {\n        // check if the following repeats are the same\n        if (\n          JSON.stringify(repeats[0]) ===\n          JSON.stringify(stsMultiplied.slice(i, i + count))\n        ) {\n          repeats.push(repeats[0]);\n          doubleNestAvailable = true;\n        } else {\n          break;\n        }\n      }\n      if (repeats.length > 1 || count > stsMultiplied.length / 2) {\n        return repeats;\n      }\n      return checkRepeats(count + 1);\n    }\n\n    const repeats = checkRepeats(2);\n\n    if (repeats.length > 1) {\n      const labelRepeats = repeats[0];\n      labels.push(`[${labelRepeats.join(\", \")}] x ${repeats.length}`);\n      // Skip all repeated ones\n      repeatCheckIdx += repeats.flat().length;\n    } else {\n      labels.push(sts);\n      // Go to the next repeat\n      repeatCheckIdx++;\n    }\n    return labels;\n  }, []);\n\n  return {\n    sts: hasDoubleNest ? nested : stsMultiplied,\n    avoidEndAvailable,\n    doubleNestAvailable,\n  };\n}\n"],"names":["SleeveInstruction","schema","measurement","centerChart","startSts","total","sleeve","decRows","finalDec","chartStartRow","row","stsCountAtChartStart","i","length","chartStartPoint","Math","floor","sts","decText","getTruelyEven","avoidEnds","count","hasDoubleNest","intro","rowType","rows","text","underarm","notes","afterList","round","getInchAndCm","sleeve_length_from_underarm","title","startRowID","slice","map","join","beforeList","cuff_length","endSts","option","avoidEndAvailable","doubleNestAvailable","stsPoints","getDec2StsList","getChangeStsList","tailSts","incDecStsList","stsCount","stsTypes","split","push","stsMultiplied","getStsListRepets","repeatCheckIdx","nested","reduce","labels","idx","repeats","checkRepeats","JSON","stringify","labelRepeats","flat"],"sourceRoot":""}