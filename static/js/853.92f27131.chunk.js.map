{"version":3,"file":"static/js/853.92f27131.chunk.js","mappings":"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","sources":["projects/pine-pullover/SleeveInstruction.tsx","../../truly-even/src/utils.ts"],"sourcesContent":["import { SectionInstruction, getInchAndCm } from \"@tanyoknits/shared\";\nimport { InstructionProps } from \"./Instruction\";\nimport { getTrulyEven } from \"@tanyoknits/truly-even\";\n\ninterface SleeveInstructionProps extends InstructionProps {\n  centerChart: { sts: number; row: number };\n}\n\nexport default function SleeveInstruction({\n  schema,\n  measurement,\n  centerChart,\n}: SleeveInstructionProps) {\n  const startSts = schema.total.sleeve;\n  const { decRows, finalDec } = schema.sleeve;\n\n  const chartStartRow = finalDec.row - centerChart.row;\n\n  let stsCountAtChartStart = startSts;\n  for (let i = 0; i < decRows.length; i++) {\n    if (decRows[i] + 1 <= chartStartRow) {\n      stsCountAtChartStart -= 2;\n    }\n  }\n\n  const chartStartPoint = Math.floor(\n    (stsCountAtChartStart - centerChart.sts) / 2\n  );\n\n  // final decrease on\n  const decText = getTrulyEven(\n    stsCountAtChartStart,\n    stsCountAtChartStart - finalDec.sts,\n    {\n      avoidEnds: true,\n      sts: \"k2tog-ssk\",\n      count: 2,\n      hasDoubleNest: true,\n    }\n  );\n\n  return (\n    <>\n      <SectionInstruction\n        intro=\"ðŸª¡ Move the sts in scrap yarn or stitch holder to US 11 / 7mm needle.\"\n        rowType=\"Pick up\"\n        rows={[\n          {\n            text: `underarm ${schema.underarm} sts`,\n            notes: `sleeve total ${startSts} sts`,\n          },\n        ]}\n        afterList={[\n          `Pm after ${Math.round(\n            schema.underarm / 2\n          )} sts - this is BOR of sleeve. Rnd 1 start here.`,\n        ]}\n        notes={`Following row numbers are based on the sleeve length from underarm, ${getInchAndCm(\n          measurement.sleeve_length_from_underarm\n        )}.`}\n      />\n      <SectionInstruction\n        rowType=\"Next rnd\"\n        rows={[{ text: `k${startSts}` }]}\n        notes={`Rep the prev row to approx ${getInchAndCm(2)}.`}\n      />\n      <SectionInstruction\n        title=\"Taper sleeve\"\n        intro=\"Dec 1 at each side of marker across two rnds\"\n        rowType=\"Rnd\"\n        startRowID={decRows[0] - 1}\n        rows={[\n          { text: \"k till 2 sts bef marker, k2tog\" },\n          {\n            text: `k2, ssk, k till marker`,\n            notes: `2 sts dec, ${startSts - 2} sts remain`,\n          },\n        ]}\n        notes={`rep at row ${decRows\n          .slice(1)\n          .map((row) => `${row}/${row + 1}`)\n          .join(\", \")} (${startSts - decRows.length * 2} sts remain)`}\n      />\n      <SectionInstruction\n        title=\"Chart A before cuff\"\n        intro={`While you work taper sleeve dec, start chart A at row ${chartStartRow}.`}\n        beforeList={[\n          `After dec, ${stsCountAtChartStart} sts left.`,\n          `From BOR, pm A at ${chartStartPoint} sts (mA is the beg of chart A.)`,\n          `From A, pm B at ${centerChart.sts} sts (mB is the end of chart A.)`,\n        ]}\n        rowType=\"Rnd\"\n        startRowID={chartStartRow - 1}\n        rows={[{ text: `k till mA, smA, work chart B, smB, k till BOR` }]}\n      />\n      <SectionInstruction\n        title=\"Final decrease\"\n        rowType=\"Rnd\"\n        startRowID={finalDec.row - 1}\n        rows={[\n          {\n            text: decText.sts.join(\", \"),\n            notes: `${finalDec.sts} dec'd, ${\n              stsCountAtChartStart - finalDec.sts\n            } sts left`,\n          },\n          { text: `Change to smaller needle, k all` },\n        ]}\n      />\n      <SectionInstruction\n        title=\"Hem 1x1 ribbing\"\n        rowType=\"Rnd\"\n        startRowID={finalDec.row + 1}\n        rows={[{ text: `(k1, p1) repeat (-) till BOR` }]}\n        notes={`Rep the prev row to approx ${getInchAndCm(\n          measurement.cuff_length\n        )}.`}\n      />\n    </>\n  );\n}\n","import {\n  getDec2StsList,\n  getChangeStsList,\n  getStsListRepeats,\n} from \"@tanyoknits/shared\";\n\nexport type IncStsType = \"m1-m1\" | \"m1r-m1l\" | \"m1l-m1r\";\nexport type DecStsType =\n  | \"k2tog-k2tog\"\n  | \"ssk-ssk\"\n  | \"k2tog-ssk\"\n  | \"ssk-k2tog\"\n  | \"cdd-cdd-k2tog\"\n  | \"k3tog-k3tog-k2tog\"\n  | \"sk2p-sk2p-ssk\"\n  | \"k3tog-sk2p-ssk\"\n  | \"sk2p-k3tog-k2tog\";\n\nexport interface OptionType {\n  avoidEnds: boolean;\n  sts: DecStsType | IncStsType;\n  count: number;\n  hasDoubleNest: boolean;\n}\n\n// Get truly even increase or decrease instruction\nexport function getTrulyEven(\n  startSts: number,\n  endSts: number,\n  option: OptionType\n): { sts: string[]; avoidEndAvailable: boolean; doubleNestAvailable: boolean } {\n  let avoidEndAvailable = true;\n  let doubleNestAvailable = false;\n\n  // Inc/Dec stitch point list\n  const stsPoints =\n    option.count === 3\n      ? getDec2StsList(startSts, endSts)\n      : getChangeStsList(startSts, endSts);\n  const { avoidEnds, sts, count, hasDoubleNest } = option;\n\n  // If users don't want to end with inc/dec at the end, start it early\n  const tailSts = Math.floor((stsPoints[0] - count) / 2);\n  if (tailSts === 0) {\n    avoidEndAvailable = false;\n  }\n  if (avoidEnds) {\n    stsPoints[0] -= tailSts;\n  }\n\n  // Generate text from all 'k' include increase or decreases stitches\n  const incDecStsList = stsPoints.map((stsCount, i) => {\n    const stsTypes = sts.split(\"-\");\n    return count === 3 &&\n      i === stsPoints.length - 1 &&\n      (endSts - startSts) % 2 !== 0 // orphan increase for 2 sts dec\n      ? `k${stsCount - 2}, ${stsTypes[2]}`\n      : `k${stsCount - count}, ${\n          // For increase, count is 0 since it's adding a new M stitch\n          i < stsPoints.length / 2 ? stsTypes[0] : stsTypes[1]\n        }`;\n  });\n  if (avoidEnds && tailSts > 0) {\n    incDecStsList.push(`k${tailSts}`);\n  }\n\n  // Repeated stitches are now presented with \"X times\"\n  const stsMultiplied: string[] = getStsListRepeats(incDecStsList);\n\n  // Check multiple increase groups are repeated\n  // e.g., [(k2, m1), (k3, m1) x 3] x 4\n  let repeatCheckIdx = 0;\n\n  const nested = stsMultiplied.reduce((labels: string[], sts, idx) => {\n    // Skip sts that's already applied to the previous repeats\n    if (idx < repeatCheckIdx) {\n      return labels;\n    }\n    // Recursive: if repeats aren't found, increase the number of repeated sts\n    // start with two (e.g., (k2, m1), (k3, m1) x 3)\n    function checkRepeats(count: number): string[][] {\n      const repeats = [stsMultiplied.slice(idx, idx + count)];\n      for (let i = idx + count; i <= stsMultiplied.length - count; i += count) {\n        // check if the following repeats are the same\n        if (\n          JSON.stringify(repeats[0]) ===\n          JSON.stringify(stsMultiplied.slice(i, i + count))\n        ) {\n          repeats.push(repeats[0]);\n          doubleNestAvailable = true;\n        } else {\n          break;\n        }\n      }\n      if (repeats.length > 1 || count > stsMultiplied.length / 2) {\n        return repeats;\n      }\n      return checkRepeats(count + 1);\n    }\n\n    const repeats = checkRepeats(2);\n\n    if (repeats.length > 1) {\n      const labelRepeats = repeats[0];\n      labels.push(`[${labelRepeats.join(\", \")}] x ${repeats.length}`);\n      // Skip all repeated ones\n      repeatCheckIdx += repeats.flat().length;\n    } else {\n      labels.push(sts);\n      // Go to the next repeat\n      repeatCheckIdx++;\n    }\n    return labels;\n  }, []);\n\n  return {\n    sts: hasDoubleNest ? nested : stsMultiplied,\n    avoidEndAvailable,\n    doubleNestAvailable,\n  };\n}\n"],"names":["SleeveInstruction","_ref","schema","measurement","centerChart","startSts","total","sleeve","_schema$sleeve","decRows","finalDec","chartStartRow","row","stsCountAtChartStart","i","length","chartStartPoint","Math","floor","sts","decText","getTrulyEven","avoidEnds","count","hasDoubleNest","_jsxs","_Fragment","children","_jsx","SectionInstruction","intro","rowType","rows","text","concat","underarm","notes","afterList","round","getInchAndCm","sleeve_length_from_underarm","title","startRowID","slice","map","join","beforeList","cuff_length","endSts","option","avoidEndAvailable","doubleNestAvailable","stsPoints","getDec2StsList","getChangeStsList","tailSts","incDecStsList","stsCount","stsTypes","split","push","stsMultiplied","getStsListRepeats","repeatCheckIdx","nested","reduce","labels","idx","repeats","checkRepeats","JSON","stringify","labelRepeats","flat"],"sourceRoot":""}